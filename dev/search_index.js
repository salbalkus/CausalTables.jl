var documenterSearchIndex = {"docs":
[{"location":"man/network-summaries/#Network-Summaries","page":"Network summaries","title":"Network Summaries","text":"","category":"section"},{"location":"man/network-summaries/","page":"Network summaries","title":"Network summaries","text":"Typically, performing causal inference on a network relies on summarizing the treatment and covariates of each unit's neighbors using some sort of summary function. For example, in a study evaluating the effect of electric vehicle adoption on air pollution, one might model the commuting patterns between counties as a network and evaluate the effect of the sum the number of electric vehicles commuting into each county. The following documents summary measures available in CausalTables.jl and how to summarize a CausalTable","category":"page"},{"location":"man/network-summaries/#Summarizing-a-CausalTable","page":"Network summaries","title":"Summarizing a CausalTable","text":"","category":"section"},{"location":"man/network-summaries/","page":"Network summaries","title":"Network summaries","text":"Data wrapped in a CausalTable includes a NamedTuple summaries which describes extra variables represented as summary variables over the network. These summary measures can be computed and added to the table by calling the summarize function on the CausalTable object.","category":"page"},{"location":"man/network-summaries/","page":"Network summaries","title":"Network summaries","text":"summarize","category":"page"},{"location":"man/network-summaries/#CausalTables.summarize-man-network-summaries","page":"Network summaries","title":"CausalTables.summarize","text":"summarize(o::CausalTable)\n\nSummarizes the data in a CausalTable object according to the NetworkSummary objects stored in its summaries attribute.\n\nArguments\n\no::CausalTable: The CausalTable object to be summarized.\n\nReturns\n\nA new CausalTable object with the original data merged with the summarized data.\n\n\n\n\n\n","category":"function"},{"location":"man/network-summaries/#Existing-Summary-Measures","page":"Network summaries","title":"Existing Summary Measures","text":"","category":"section"},{"location":"man/network-summaries/","page":"Network summaries","title":"Network summaries","text":"The following lists summary measures currently available off-the-shelf in CausalTables.jl. Examples on their use are provided in Generating Data for Statistical Experiments and Turning data into a CausalTable.","category":"page"},{"location":"man/network-summaries/","page":"Network summaries","title":"Network summaries","text":"Sum\nMean\nAllOrderStatistics\nKOrderStatistics","category":"page"},{"location":"man/network-summaries/#CausalTables.Sum-man-network-summaries","page":"Network summaries","title":"CausalTables.Sum","text":"Sum <: NetworkSummary\n\nA NetworkSummary which sums the values of the target variable for each unit connected in the adjacency matrix of a StructuralCausalModel or CausalTable\n\nFields\n\ntarget::Symbol: A key denoting the target variable to be summarized in the DataGeneratingProcess of the StructuralCausalModel; or, alternatively, the target variable to be summarized in the data attribute of a CausalTable.\nmatrix::Symbol: A key denoting the adjacency matrix over which summary is computed in the DataGeneratingProcess of the StructuralCausalModel; or, alternatively, the key of the adjacency matrix in the arrays attribute of a CausalTable.\nweights::Union{Symbol, Nothing}: An optional variable by which each unit may be weighted in the summary.\n\n\n\n\n\n","category":"type"},{"location":"man/network-summaries/#CausalTables.Mean-man-network-summaries","page":"Network summaries","title":"CausalTables.Mean","text":"Mean <: NetworkSummary\n\nA NetworkSummary which computes the mean of the target variable among each unit connected in the adjacency matrix.\n\nFields\n\ntarget::Symbol: A key denoting the target variable to be summarized in the DataGeneratingProcess of the StructuralCausalModel; or, alternatively, the target variable to be summarized in the data attribute of a CausalTable.\nmatrix::Symbol: A key denoting the adjacency matrix over which summary is computed in the DataGeneratingProcess of the StructuralCausalModel; or, alternatively, the key of the adjacency matrix in the arrays attribute of a CausalTable.\nweights::Union{Symbol, Nothing}: An optional variable by which each unit may be weighted in the summary.\n\n\n\n\n\n","category":"type"},{"location":"man/network-summaries/#CausalTables.AllOrderStatistics-man-network-summaries","page":"Network summaries","title":"CausalTables.AllOrderStatistics","text":"AllOrderStatistics <: NetworkSummary\n\nA NetworkSummary which computes all ordered values of the target variable among each unit's connected neighbors in the adjacency matrix.\n\nFields\n\ntarget::Symbol: A key denoting the target variable to be summarized in the DataGeneratingProcess of the StructuralCausalModel; or, alternatively, the target variable to be summarized in the data attribute of a CausalTable.\nmatrix::Symbol: A key denoting the adjacency matrix over which summary is computed in the DataGeneratingProcess of the StructuralCausalModel; or, alternatively, the key of the adjacency matrix in the arrays attribute of a CausalTable.\nweights::Union{Symbol, Nothing}: An optional variable by which each unit may be weighted in the summary.\n\n\n\n\n\n","category":"type"},{"location":"man/network-summaries/#CausalTables.KOrderStatistics-man-network-summaries","page":"Network summaries","title":"CausalTables.KOrderStatistics","text":"KOrderStatistics <: NetworkSummary\n\nA NetworkSummary which computes the top K ordered values of the target variable among each unit's connected neighbors in the adjacency matrix.\n\nFields\n\ntarget::Symbol: A key denoting the target variable to be summarized in the DataGeneratingProcess of the StructuralCausalModel; or, alternatively, the target variable to be summarized in the data attribute of a CausalTable.\nmatrix::Symbol: A key denoting the adjacency matrix over which summary is computed in the DataGeneratingProcess of the StructuralCausalModel; or, alternatively, the key of the adjacency matrix in the arrays attribute of a CausalTable.\nweights::Union{Symbol, Nothing}: An optional variable by which each unit may be weighted in the summary.\n\n\n\n\n\n","category":"type"},{"location":"man/network-summaries/#Defining-Your-Own-Summary-Measures","page":"Network summaries","title":"Defining Your Own Summary Measures","text":"","category":"section"},{"location":"man/network-summaries/","page":"Network summaries","title":"Network summaries","text":"Forthcoming.","category":"page"},{"location":"man/estimands/#Approximating-Ground-Truth-Causal-Estimands","page":"Approximating ground truth causal estimands","title":"Approximating Ground Truth Causal Estimands","text":"","category":"section"},{"location":"man/estimands/","page":"Approximating ground truth causal estimands","title":"Approximating ground truth causal estimands","text":"In causal inference, we are often interested in the value of some causal estimand, such as the average treatment effect (ATE) or the average policy effect (APE). These estimands are defined in terms of counterfactual outcomes, which are the outcomes that would have been observed had the treatment been different. CausalTables.jl provides functions that numerically approximate the values of several common estimands given a ground truth  StructuralCausalModel object. This can be useful for evaluating the performance of causal inference methods on simulated data. ","category":"page"},{"location":"man/estimands/#Estimands-API","page":"Approximating ground truth causal estimands","title":"Estimands API","text":"","category":"section"},{"location":"man/estimands/","page":"Approximating ground truth causal estimands","title":"Approximating ground truth causal estimands","text":"Modules = [CausalTables]\nOrder   = [:type, :function]\nPages = [\"estimands.jl\"]","category":"page"},{"location":"man/estimands/#CausalTables.additive_mtp-Tuple{Any}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.additive_mtp","text":"additive_mtp(δ)\n\nConstructs a function that adds a constant (or constant vector) δ to the treatment variable(s) in a CausalTable object. This function is intended to be used as an argument to ape.\n\nArguments\n\nδ: The \"additive shift\" to be applied to the treatment variable of a CausalTable.\n\nReturns\n\nA function that takes a CausalTable object as input and returns a column table of treatments that have been shifted by δ units.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Normal(L)),\n    Y ~ @.(Normal(A + 2 * L + 1))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\nape(scm, additive_mtp(0.5))\n\n\n\n\n\n","category":"method"},{"location":"man/estimands/#CausalTables.ape-Tuple{StructuralCausalModel, Function}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.ape","text":"ape(scm::StructuralCausalModel, intervention::Function; samples = 10^6)\n\nApproximate the average policy effect for a given structural causal model (SCM), along with its efficiency bound. This is also known as the causal effect of a modified treatment policy, and is approximated using Monte Carlo sampling. Note that unless intervention is piecewise smooth invertible, the estimated statistical quantity may not have a causal interpretation; see Haneuse and Rotnizky (2013).\n\nConvenience functions for generating intervention functions include additive_mtp and multiplicative_mtp, which construct functions that respectively add or multiply a constant (or constant vector) to the treatment variable(s). One can also implement their own intervention function; this function must take as input a CausalTable object and return a NamedTuple object with each key indexing a treatment variable that has been modified according to the intervention. Also see cast_matrix_to_table_function for a convenience function for constructing interventions.\n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nintervention::Function: The intervention function to apply to the SCM.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The ATU approximation.\neff_bound: The variance of the difference between the natural and counterfactual responses, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = CausalTables.@dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Normal(L)),\n    Y ~ @.(Normal(A + 2 * L + 1))\n)\nscm = CausalTables.StructuralCausalModel(dgp, [:A], [:Y], [:L])\nape(scm, additive_mtp(0.5))\nape(scm, multiplicative_mtp(2.0))\n\n# example of a custom intervention function\ncustom_intervention = cast_matrix_to_table_function(x -> exp.(x))\nape(scm, custom_intervention)\n\n\n\n\n\n\n","category":"method"},{"location":"man/estimands/#CausalTables.ate-Tuple{StructuralCausalModel}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.ate","text":"ate(scm::StructuralCausalModel; samples = 10^6)\n\nApproximate the average treatment effect (ATE) for a given structural causal model (SCM), along with its efficiency bound. This statistical quantity is approximated using Monte Carlo sampling.\n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The ATE approximation.\neff_bound: The variance of the counterfactual response, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\nate(scm, treat_all, treat_none)\n\n\n\n\n\n","category":"method"},{"location":"man/estimands/#CausalTables.att-Tuple{StructuralCausalModel}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.att","text":"att(scm::StructuralCausalModel; samples = 10^6)\n\nApproximate the average treatment effect among the treated (ATT) for a given structural causal model (SCM), along with its efficiency bound. This statistical quantity is approximated using Monte Carlo sampling.\n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The ATT approximation.\neff_bound: The variance of the counterfactual response, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\natt(scm, treat_all, treat_none)\n\n\n\n\n\n","category":"method"},{"location":"man/estimands/#CausalTables.atu-Tuple{StructuralCausalModel}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.atu","text":"atu(scm::StructuralCausalModel; samples = 10^6)\n\nApproximate the average treatment effect among the untreated (ATU) for a given structural causal model (SCM), along with its efficiency bound. This statistical quantity is approximated using Monte Carlo sampling.\n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The ATU approximation.\neff_bound: The variance of the counterfactual response, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\natu(scm, treat_all, treat_none)\n\n\n\n\n\n","category":"method"},{"location":"man/estimands/#CausalTables.cast_matrix_to_table_function-Tuple{Function}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.cast_matrix_to_table_function","text":"cast_matrix_to_table_function(func::Function)\n\nWraps a given function func that operates on a matrix and returns a new function that operates on a CausalTable object. The returned function converts the CausalTable's treatment matrix to a table, applies func to this matrix, and then converts the result back to a column table with the same header as the original treatment matrix.\n\nArguments\n\nfunc::Function: A function that takes a matrix as input and returns a matrix.\n\nReturns\n\nA function that takes a CausalTable object as input and returns a column table.\n\nExample\n\ncustom_intervention = cast_matrix_to_table_function(x -> exp.(x))\n\n\n\n\n\n","category":"method"},{"location":"man/estimands/#CausalTables.cfdiff-Tuple{StructuralCausalModel, Function, Function}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.cfdiff","text":"cfdiff(scm::StructuralCausalModel, intervention1::Function, intervention2::Function; samples = 10^6)\n\nApproximate the difference between two counterfactual response means – that under intervention1 having been applied to the treatment, and that under intervention2 – for a given structural causal model (SCM), along with its efficiency bound. These statistical quantities are approximated using Monte Carlo sampling. \n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nintervention1::Function: The first intervention function to be contrasted.\nintervention2::Function: The second intervention function to be contrasted.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The mean difference in counterfactual outcomes.\neff_bound: The variance of the difference in counterfactual responses, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\ncfdiff(scm, treat_all, treat_none)\n\n\n\n\n\n","category":"method"},{"location":"man/estimands/#CausalTables.cfmean-Tuple{StructuralCausalModel, Function}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.cfmean","text":"cfmean(scm::StructuralCausalModel, intervention::Function; samples = 10^6)\n\nApproximate the counterfactual mean of the response had intervention been applied to the treatment, along with its efficiency bound, for a given structural causal model (SCM). These statistical quantities are approximated using Monte Carlo sampling. \n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nintervention::Function: The intervention function to apply to the SCM.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The mean of the counterfactual outcomes.\neff_bound: The variance of the counterfactual response, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\ncfmean(scm, treat_all)\ncfmean(scm, treat_none)\n\n\n\n\n\n","category":"method"},{"location":"man/estimands/#CausalTables.draw_counterfactual-Tuple{StructuralCausalModel, CausalTable, Function}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.draw_counterfactual","text":"draw_counterfactual(scm::StructuralCausalModel, parents::CausalTable, intervention::Function) -> Vector\n\nGenerate counterfactual responses based on a given structural causal model (SCM), a table of response parents, and an intervention function. That is, sample the responses that would have occurred had some intervention been applied to the treatment specified by the structural causal model.\n\nArguments\n\nscm::StructuralCausalModel: The structural causal model used to generate counterfactual outcomes.\nparents::CausalTable: A table containing the variables causally preceding the response variable.\nintervention::Function: A function that defines the intervention to be applied to the parent variables.\n\nReturns\n\nA vector of counterfactual responses.\n\n\n\n\n\n","category":"method"},{"location":"man/estimands/#CausalTables.multiplicative_mtp-Tuple{Any}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.multiplicative_mtp","text":"multiplicative_mtp(δ)\n\nConstructs a function that scales the treatment variable(s) in a CausalTable object by a constant δ. This function is intended to be used as an argument to ape.\n\nArguments\n\nδ: The \"multiplicative shift\" to be applied to the treatment variable of a CausalTable.\n\nReturns\n\nA function that takes a CausalTable object as input and returns a column table of treatments that have been scaled by δ units.\n\nExample\n\nusing Distributions\ndgp = CausalTables.@dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Normal(L)),\n    Y ~ @.(Normal(A + 2 * L + 1))\n)\nscm = CausalTables.StructuralCausalModel(dgp, [:A], [:Y], [:L])\nape(scm, multiplicative_mtp(2.0))\n\n\n\n\n\n","category":"method"},{"location":"man/estimands/#CausalTables.treat_all-Tuple{CausalTable}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.treat_all","text":"treat_all(ct::CausalTable)\n\nIntervenes on a CausalTable object by setting all treatment variables to 1.\n\nArguments\n\nct::CausalTable: A CausalTable object with a univariate binary treatment.\n\nReturns\n\nA NamedTuple object with the same header as the treatment matrix in ct, where each treatment variable is set to 1.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\ndata = rand(scm, 100)\ntreat_all(data)\n\n\n\n\n\n","category":"method"},{"location":"man/estimands/#CausalTables.treat_none-Tuple{Any}-man-estimands","page":"Approximating ground truth causal estimands","title":"CausalTables.treat_none","text":"treat_all(ct::CausalTable)\n\nIntervenes on a CausalTable object by setting all treatment variables to 0.\n\nArguments\n\nct::CausalTable: A CausalTable object with a univariate binary treatment.\n\nReturns\n\nA NamedTuple object with the same header as the treatment matrix in ct, where each treatment variable is set to 0.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\ndata = rand(scm, 100)\ntreat_none(data)\n\n\n\n\n\n","category":"method"},{"location":"man/ground-truth/#Computing-Ground-Truth-Conditional-Distributions","page":"Computing ground truth conditional distributions","title":"Computing Ground Truth Conditional Distributions","text":"","category":"section"},{"location":"man/ground-truth/","page":"Computing ground truth conditional distributions","title":"Computing ground truth conditional distributions","text":"Once we've defined a DGP and have some table of data with variables matching those of our DGP, we can compute the ground truth conditional distributions of any variable in a CausalTable (given a corresponding DGP) using the condensity function. This returns a Distribution object from the package Distributions.jl.","category":"page"},{"location":"man/ground-truth/","page":"Computing ground truth conditional distributions","title":"Computing ground truth conditional distributions","text":"Let's see an example. First, we'll define a DGP:","category":"page"},{"location":"man/ground-truth/","page":"Computing ground truth conditional distributions","title":"Computing ground truth conditional distributions","text":"using Graphs\nusing CausalTables\nusing Random\nusing Distributions\n\ndgp = @dgp(\n        W ~ Binomial(10, 0.3),\n        X ~ (@. Normal(W + 1)),\n        A = adjacency_matrix(barabasi_albert(length(X), 2)),\n        Xs $ Sum(:X, :A),\n        Y ~ (@. LogNormal(log(0.2 * Xs + 4), 0.1 * W + 1))\n    )\n\nscm = StructuralCausalModel(\n    dgp;\n    treatment = :X,\n    response = :Y,\n    confounders = [:W]\n)","category":"page"},{"location":"man/ground-truth/","page":"Computing ground truth conditional distributions","title":"Computing ground truth conditional distributions","text":"Now, let's generate some data and compute the ground truth conditional distributions of the variables in the data. Note that if the DGP attempts to summarize a variable with no neighbors in a graph, the resulting conditional distribution will currently be Binomial(0, 0.5), which denotes a point-mass distribution at 0.","category":"page"},{"location":"man/ground-truth/","page":"Computing ground truth conditional distributions","title":"Computing ground truth conditional distributions","text":"Random.seed!(1);\ndata = rand(scm, 5)\nW_distribution = condensity(scm, data, :W)\nX_distribution = condensity(scm, data, :X)\nXs_distribution = condensity(scm, data, :Xs)","category":"page"},{"location":"man/ground-truth/","page":"Computing ground truth conditional distributions","title":"Computing ground truth conditional distributions","text":"One can also compute the ground truth conditional mean of a variable in a CausalTable using the conmean function:","category":"page"},{"location":"man/ground-truth/","page":"Computing ground truth conditional distributions","title":"Computing ground truth conditional distributions","text":"Y = conmean(scm, data, :Y)","category":"page"},{"location":"man/ground-truth/#Ground-Truth-Conditional-Distributions-API","page":"Computing ground truth conditional distributions","title":"Ground Truth Conditional Distributions API","text":"","category":"section"},{"location":"man/ground-truth/","page":"Computing ground truth conditional distributions","title":"Computing ground truth conditional distributions","text":"Modules = [CausalTables]\nOrder   = [:type, :function]\nPages = [\"conditional_density.jl\"]","category":"page"},{"location":"man/ground-truth/#CausalTables.condensity-Tuple{StructuralCausalModel, CausalTable, Symbol}-man-ground-truth","page":"Computing ground truth conditional distributions","title":"CausalTables.condensity","text":"condensity(scm::StructuralCausalModel, ct::CausalTable, name::Symbol)\n\nCompute the conditional density of a variable in a StructuralCausalModel given a CausalTable.\n\nArguments\n\nscm::StructuralCausalModel: The StructuralCausalModel representing the data generating process.\nct::CausalTable: The CausalTable containing the observed data.\nname::Symbol: The variable for which to compute the conditional density.\n\nReturns\n\nThe conditional density of the variable var given the observed data.\n\n\n\n\n\n","category":"method"},{"location":"man/ground-truth/#CausalTables.conmean-Tuple{StructuralCausalModel, CausalTable, Symbol}-man-ground-truth","page":"Computing ground truth conditional distributions","title":"CausalTables.conmean","text":"conmean(scm::StructuralCausalModel, ct::CausalTable, name::Symbol)\n\nCompute the conditional mean of a variable in a CausalTable based on a DataGeneratingProcess.\n\nArguments\n\nscm::StructuralCausalModel: The StructuralCausalModel object representing the data generating process.\nct::CausalTable: The CausalTable object representing the data.\nname::Symbol: The variable for which to compute the conditional mean.\n\nReturns\n\nAn array of conditional means for the specified variable.\n\n\n\n\n\n","category":"method"},{"location":"man/ground-truth/#CausalTables.convar-Tuple{StructuralCausalModel, CausalTable, Symbol}-man-ground-truth","page":"Computing ground truth conditional distributions","title":"CausalTables.convar","text":"convar(scm::StructuralCausalModel, ct::CausalTable, name::Symbol)\n\nCompute the conditional variance of a variable in a CausalTable based on a DataGeneratingProcess.\n\nArguments\n\nscm::StructuralCausalModel: The StructuralCausalModel object representing the data generating process.\nct::CausalTable: The CausalTable object representing the data.\nname::Symbol: The variable for which to compute the conditional mean.\n\nReturns\n\nAn array of conditional variances for the specified variable.\n\n\n\n\n\n","category":"method"},{"location":"man/generating-data/#Generating-Data-for-Statistical-Experiments","page":"Generating data for statistical experiments","title":"Generating Data for Statistical Experiments","text":"","category":"section"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"When evaluating a causal inference method, we often want to test it on data from a known causal model. CausalTables.jl allows us to define a DataGeneratingProcess (or DGP) to do just that. ","category":"page"},{"location":"man/generating-data/#Defining-a-DataGeneratingProcess","page":"Generating data for statistical experiments","title":"Defining a DataGeneratingProcess","text":"","category":"section"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"A data generating process describes a mechanism by which draws from random variables are simulated. It typically takes the form of a sequence of conditional distributions. CausalTables allows us to define a DGP as a DataGeneratingProcess object, which takes three arguments: the names of variables generated at each step, the types of these variables, and funcs, an array of functions of the form (; O...) -> *some code. ","category":"page"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"Suppose, for example, that we wanted to simulate data from the following DGP:","category":"page"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"beginalign*\n    W sim textDiscreteUniform(1 5) \n    X sim textNormal(W 1) \n    Y sim textNormal(X + 02W 1)\nendalign*","category":"page"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"where X is the treatment, Y is the response, and W is a confounding variable affecting both X and Y. A verbose and inconvenient (albeit correct) way to define this DGP would be as follows:","category":"page"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"using Distributions\nusing CausalTables\n\nDataGeneratingProcess(\n    [:W, :X, :Y],\n    [:distribution, :distribution, :distribution],\n    [\n        (; O...) -> DiscreteUniform(1, 5), \n        (; O...) -> (@. Normal(O.W, 1)),\n        (; O...) -> (@. Normal(O.X + 0.2 * O.W, 1))\n    ]\n)","category":"page"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"where ; O... syntax is a shorthand for a function that takes keyword arguments corresponding to the names of the variables in the DGP. ","category":"page"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"However, a much more convenient way to define this DGP is using the @dgp macro, which takes a sequence of conditional distributions of the form [variable name] ~ Distribution(args...) and deterministic variable assignments of the form [variable name] = f(...) and automatically generates a valid DataGeneratingProcess. For example, the easier way to define the DGP above is as follows:","category":"page"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"using CausalTables\ndistributions = @dgp(\n        W ~ DiscreteUniform(1, 5),\n        X ~ (@. Normal(W, 1)),\n        Y ~ (@. Normal(X + 0.2 * W, 1))\n    )","category":"page"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"Note that with the @dgp macro, any symbol (that is, any string of characters prefixed by a colon, as in :W or :X) is automatically replaced with the corresponding previously-defined variable in the process. For instance, in Normal(:W, 1), the :W will be replaced automatically with the distribution we defined as W earlier in the sequence. ","category":"page"},{"location":"man/generating-data/#Defining-a-StructuralCausalModel","page":"Generating data for statistical experiments","title":"Defining a StructuralCausalModel","text":"","category":"section"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"In CausalTables.jl, a StructuralCausalModel is a data generating process endowed with some causal interpretation. Constructing a StructuralCausalModel allows users to randomly draw a CausalTable with the necessary components from the DataGeneratingProcess they've defined. With the above DataGeneratingProcess in hand, we can define a StructuralCausalModel object like so – treatment, response, and confounder variables in the causal model are specified as keyword arguments to the DataGeneratingProcess constructor:","category":"page"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"dgp = StructuralCausalModel(\n    distributions;\n    treatment = :X,\n    response = :Y,\n    confounders = [:W]\n)","category":"page"},{"location":"man/generating-data/#Networks-of-Causally-Connected-Units","page":"Generating data for statistical experiments","title":"Networks of Causally-Connected Units","text":"","category":"section"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"In some cases, we might work with data in which units may not be causally independent, but rather, in which one unit's variables could dependent on some summary function of its neighbors. Generating data from such a model can be done by adding lines of the form Xs $ NetworkSummary to the @dgp macro.","category":"page"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"Here's an example of how such a DataGeneratingProcess might be constructed:","category":"page"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"using Graphs\nusing CausalTables\nusing Distributions\n\ndgp = @dgp(\n        W ~ DiscreteUniform(1, 5),\n        n = length(W),\n        A = adjacency_matrix(erdos_renyi(n, 0.5)),\n        Ws $ Sum(:W, :A),\n        X ~ (@. Normal(Ws, 1)),\n        Xs $ Sum(:X, :A),\n        Y ~ (@. Normal(Xs + 0.2 * Ws, 1))\n    )\n\nscm = StructuralCausalModel(\n    dgp;\n    treatment = :X,\n    response = :Y,\n    confounders = [:W, :Ws]\n)","category":"page"},{"location":"man/generating-data/#StructuralCausalModel-API","page":"Generating data for statistical experiments","title":"StructuralCausalModel API","text":"","category":"section"},{"location":"man/generating-data/","page":"Generating data for statistical experiments","title":"Generating data for statistical experiments","text":"Modules = [CausalTables]\nOrder   = [:type, :function]\nPages = [\"data_generating_process.jl\", \"structural_causal_model.jl\"]","category":"page"},{"location":"man/generating-data/#CausalTables.DataGeneratingProcess-man-generating-data","page":"Generating data for statistical experiments","title":"CausalTables.DataGeneratingProcess","text":"mutable struct DataGeneratingProcess\n\nA struct representing a data generating process.\n\nFields\n\nnames: An array of symbols representing the names of the variables.\ntypes: An array of symbols representing the types of the variables.\nfuncs: An array of functions representing the generating functions for each variable.\n\n\n\n\n\n","category":"type"},{"location":"man/generating-data/#CausalTables.StructuralCausalModel-man-generating-data","page":"Generating data for statistical experiments","title":"CausalTables.StructuralCausalModel","text":"struct StructuralCausalModel\n\nA struct representing a structural causal model (SCM). This includes a DataGeneratingProcess \n\nArguments\n\ndgp::DataGeneratingProcess: The data generating process from which random data will be drawn.\ntreatment::Vector{Symbol}: The variables representing the treatment.\nresponse::Vector{Symbol}: The variables representing the response.\nconfounders::Vector{Symbol}: The variables representing the confounders.\narraynames: Names of auxiliary variables used in the DataGeneratingProcess that are not included as \"tabular\" variables. Most commonly used to denote names of adjacency matrices used to compute summary functions of previous steps. \n\n\n\n\n\n","category":"type"},{"location":"man/generating-data/#Base.rand-Tuple{StructuralCausalModel, Int64}-man-generating-data","page":"Generating data for statistical experiments","title":"Base.rand","text":"rand(scm::StructuralCausalModel, n::Int)\n\nGenerate random data from a Structural Causal Model (SCM) using the specified number of samples.\n\nArguments\n\nscm::StructuralCausalModel: The Structural Causal Model from which to generate data.\nn::Int: The number of samples to generate.\n\nReturns\n\nA CausalTable object containing the generated data.\n\n\n\n\n\n","category":"method"},{"location":"man/formatting/#Turning-Your-Data-Into-a-CausalTable","page":"Turning data into a CausalTable","title":"Turning Your Data Into a CausalTable","text":"","category":"section"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"One of the main purposes of CausalTables.jl is to wrap a Table of data in Julia in order to provide it as input to some other causal inference package. Given a Table of some data, we can turn it into a CausalTable by specifying the treatment, response, and control variables. ","category":"page"},{"location":"man/formatting/#Tables-with-Causally-Independent-Units","page":"Turning data into a CausalTable","title":"Tables with Causally Independent Units","text":"","category":"section"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"The code below provides an example of how to wrap the Boston Housing dataset as a CausalTable to answer causal questions of the form \"How would changing nitrous oxide air pollution (NOX) within Boston-area towns affect median home value (MEDV)?\" ","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"using CausalTables\nusing MLDatasets: BostonHousing\nusing DataFrames\n\ndf = BostonHousing().dataframe\n\n# Wrapping the dataset in a CausalTable\nctbl = CausalTable(df; treatment = :NOX, response = :MEDV, confounders = [:CRIM, :ZN, :INDUS, :CHAS, :B, :DIS, :LSTAT])\n\nnothing # hide","category":"page"},{"location":"man/formatting/#Tables-with-Network-Dependent-Units","page":"Turning data into a CausalTable","title":"Tables with Network-Dependent Units","text":"","category":"section"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"The previous example assumes that each unit (row in the Table, in this case df), is \"causally independent\" of every other unit – that is, the treatment of one unit does not affect the response of any other unit. In some cases, however, we might work with data in which units may not be causally independent, but rather, in which one unit's variables could dependent on some summary function of its neighbors. ","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"Each CausalTable has an \"arrays\" argument, a NamedTuple that can store adjacency matrices and other miscellaneous parameters that denote the causal relationships between variables. The code below provides an example of how such a CausalTable might be constructed using the Karate Club dataset. Treatment is defined as the number of friends a club member has, denoted by the summary function parameter summaries = (friends = Friends(:F),). Hence, this answers the causal question \"how would changing a subject's number of friends (friends) affect which club they are likely to join (labels_clubs)?\" ","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"We store the network relationships between units as an adjacency matrix F by assigning it to the arrays parameters. This allows the Friends(:F) summary function to access it when calling summarize(ctbl). More detail on the types of NetworkSummary that can be used in a dependent-data CausalTable can be found in Network Summaries","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"using CausalTables\nusing MLDatasets\nusing Graphs\n\n# Get a Table of Karate Club data from MLDatasets\ndata = KarateClub()\ntbl = data.graphs[1].node_data\n\n# Convert the karate club data into a Graphs.jl graph object\ng = SimpleGraphFromIterator([Edge(x...) for x in zip(data.graphs[1].edge_index...)])\n\n# Store the \"friends\" as an the adjacency matrix in a NamedTuple\n# Note that the input to arrays must be a NamedTuple, even if there is only one summary variable, \n# so the trailing comma is necessary.\nm = (F = adjacency_matrix(g),)\n\n# Construct a CausalTable with the adjacency matrix stored in `arrays` and a summary variable recording the number of friends\nctbl = CausalTable(tbl; treatment = :friends, response = :labels_clubs, arrays = m, summaries = (friends = Friends(:F),))\n\nnothing # hide","category":"page"},{"location":"man/formatting/#CausalTable-API","page":"Turning data into a CausalTable","title":"CausalTable API","text":"","category":"section"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"Modules = [CausalTables]\nOrder   = [:type, :function]\nPages = [\"causal_table.jl\"]","category":"page"},{"location":"man/formatting/#CausalTables.getscm-Tuple{CausalTable}-man-formatting","page":"Turning data into a CausalTable","title":"CausalTables.getscm","text":"getscm(o::CausalTable)\n\nGet the structural causal model (SCM) of a CausalTable object.\n\nThis function merges the column table of the CausalTable object with its arrays.\n\nArguments\n\no::CausalTable: The CausalTable object.\n\nReturns\n\nA merged table containing the column table and arrays of the CausalTable object.\n\n\n\n\n\n","category":"method"},{"location":"man/formatting/#CausalTables.replace-Tuple{CausalTable}-man-formatting","page":"Turning data into a CausalTable","title":"CausalTables.replace","text":"replace(o::CausalTable; kwargs...)\n\nReplace the fields of a CausalTable object with the provided keyword arguments.\n\nArguments\n\no::CausalTable: The CausalTable object to be replaced.\nkwargs...: Keyword arguments specifying the new values for the fields.\n\nReturns\n\nA new CausalTable object with the specified fields replaced.\n\n\n\n\n\n","category":"method"},{"location":"#CausalTables.jl","page":"Home","title":"CausalTables.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for storing and simulating data for causal inference in Julia.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CausalTables.jl can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg> add CausalTables","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CausalTables.jl has three main functionalities:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generating simulation data using a StructuralCausalModel.\nComputing \"ground truth\" conditional distributions, moments, counterfactuals, and counterfactual functionals from a StructuralCausalModel and a CausalTable.\nWrapping an existing Table as a CausalTable object for use by external packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The examples below illustrate each of these three functionalities.","category":"page"},{"location":"#Simulating-Data-from-a-DataGeneratingProcess","page":"Home","title":"Simulating Data from a DataGeneratingProcess","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To set up a statistical simulation using CausalTables.jl, we first define a StructuralCausalModel (SCM). This consists of two parts: a DataGeneratingProcess (DGP) that controls how the data is generated, and a list of variables to define the basic structure of the underlying causal diagram.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A DataGeneratingProcess can be constructed using the @dgp macro, which takes a sequence of conditional distributions of the form [variable name] ~ Distribution(args...) and returns a DataGeneratingProcess object. Then, one can construct an StructuralCausalModel by passing the DGP to its construct, along with labels of the treatment and response variables. Note that using Distributions is almost always required before defining a DGP, since the package Distributions.jl is used to define the conditional distribution of random components at each step.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CausalTables\nusing Random\nusing Distributions\n\ndgp = @dgp(\n        W ~ DiscreteUniform(1, 5),\n        X ~ (@. Normal(W, 1)),\n        Y ~ (@. Normal(X + 0.2 * W, 1))\n    )\n\nscm = StructuralCausalModel(\n    dgp;\n    treatment = :X,\n    response = :Y,\n    confounders = [:W]\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"One we've defined our list of distribution functions, we can generate data from the DGP using the rand function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Random.seed!(1);\ndata = rand(scm, 5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more detailed guide of how to generate data please refer to Generating Data.","category":"page"},{"location":"#Computing-Ground-Truth-Functionals","page":"Home","title":"Computing Ground Truth Functionals","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once we've defined a DGP, we can approximate ground truth statistical functionals along with their efficiency bounds (variance of the counterfactual outcome) for a specified SCM using built-in functions. In general, these include","category":"page"},{"location":"","page":"Home","title":"Home","text":"Counterfactual Means (cfmean)\nCounterfactual Differences (cfdiff)\nAverage Treatment Effect (ate), including among the Treated (att) and Untreated (atu)\nAverage Policy Effect (ape), also known as the causal effect of a Modified Treatment Policy. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the complete API of available ground truth causal estimands, see Estimands","category":"page"},{"location":"","page":"Home","title":"Home","text":"cfmean(scm, additive_mtp(1))\n\n# output\n(μ = 4.599337273915866, eff_bound = 4.881412474779794)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For problems that involving functionals not available through CausalTables.jl or that require more fine-grained knowledge of the true conditional distributions for a given dataset, this package also implements the condensity function. This function computes the true conditional distributions of any variable in a CausalTable (given a corresponding DGP). This returns a vector of Distribution objects from the package Distributions.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"X_distribution = condensity(scm, data, :X)\n\n# output\n5-element Vector{Normal{Float64}}:\n Distributions.Normal{Float64}(μ=1.0, σ=1.0)\n Distributions.Normal{Float64}(μ=2.0, σ=1.0)\n Distributions.Normal{Float64}(μ=4.0, σ=1.0)\n Distributions.Normal{Float64}(μ=4.0, σ=1.0)\n Distributions.Normal{Float64}(μ=5.0, σ=1.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For convenience, there also exists conmean and convar functions that extracts the true conditional mean and variance of a specific variable the CausalTable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Y_var = convar(scm, data, :Y)\nY_mean = conmean(scm, data, :Y)\n\n# output\n5-element Vector{Float64}:\n 1.467564418628885\n 4.149933692528245\n 3.973979208080703\n 3.757247582108903\n 5.670866154143596","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more detailed guide of how to compute ground truth conditional distributions please refer to Computing Ground Truth Conditional Distributions.","category":"page"},{"location":"#Wrapping-an-existing-Table-as-a-CausalTable","page":"Home","title":"Wrapping an existing Table as a CausalTable","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have a table of data that you would like to use with CausalTables.jl without defining a corresponding DataGeneratingProcess (i.e. to use with another package) you can wrap it as a CausalTable using the corresponding constructor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tbl = (W = rand(1:5, 10), X = randn(10), Y = randn(10))\nctbl = CausalTable(tbl; treatment = :X, response = :Y, confounders = [:W])","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more detailed guide of how to wrap an existing table as a CausalTable please refer to Turning Your Data Into a CausalTable.","category":"page"},{"location":"man/api/#CausalTables.jl-API","page":"API","title":"CausalTables.jl API","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"Modules = [CausalTables]\nOrder   = [:type, :function]\nPages = [\"estimands.jl\"]","category":"page"},{"location":"man/api/#CausalTables.additive_mtp-Tuple{Any}-man-api","page":"API","title":"CausalTables.additive_mtp","text":"additive_mtp(δ)\n\nConstructs a function that adds a constant (or constant vector) δ to the treatment variable(s) in a CausalTable object. This function is intended to be used as an argument to ape.\n\nArguments\n\nδ: The \"additive shift\" to be applied to the treatment variable of a CausalTable.\n\nReturns\n\nA function that takes a CausalTable object as input and returns a column table of treatments that have been shifted by δ units.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Normal(L)),\n    Y ~ @.(Normal(A + 2 * L + 1))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\nape(scm, additive_mtp(0.5))\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.ape-Tuple{StructuralCausalModel, Function}-man-api","page":"API","title":"CausalTables.ape","text":"ape(scm::StructuralCausalModel, intervention::Function; samples = 10^6)\n\nApproximate the average policy effect for a given structural causal model (SCM), along with its efficiency bound. This is also known as the causal effect of a modified treatment policy, and is approximated using Monte Carlo sampling. Note that unless intervention is piecewise smooth invertible, the estimated statistical quantity may not have a causal interpretation; see Haneuse and Rotnizky (2013).\n\nConvenience functions for generating intervention functions include additive_mtp and multiplicative_mtp, which construct functions that respectively add or multiply a constant (or constant vector) to the treatment variable(s). One can also implement their own intervention function; this function must take as input a CausalTable object and return a NamedTuple object with each key indexing a treatment variable that has been modified according to the intervention. Also see cast_matrix_to_table_function for a convenience function for constructing interventions.\n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nintervention::Function: The intervention function to apply to the SCM.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The ATU approximation.\neff_bound: The variance of the difference between the natural and counterfactual responses, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = CausalTables.@dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Normal(L)),\n    Y ~ @.(Normal(A + 2 * L + 1))\n)\nscm = CausalTables.StructuralCausalModel(dgp, [:A], [:Y], [:L])\nape(scm, additive_mtp(0.5))\nape(scm, multiplicative_mtp(2.0))\n\n# example of a custom intervention function\ncustom_intervention = cast_matrix_to_table_function(x -> exp.(x))\nape(scm, custom_intervention)\n\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.ate-Tuple{StructuralCausalModel}-man-api","page":"API","title":"CausalTables.ate","text":"ate(scm::StructuralCausalModel; samples = 10^6)\n\nApproximate the average treatment effect (ATE) for a given structural causal model (SCM), along with its efficiency bound. This statistical quantity is approximated using Monte Carlo sampling.\n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The ATE approximation.\neff_bound: The variance of the counterfactual response, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\nate(scm, treat_all, treat_none)\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.att-Tuple{StructuralCausalModel}-man-api","page":"API","title":"CausalTables.att","text":"att(scm::StructuralCausalModel; samples = 10^6)\n\nApproximate the average treatment effect among the treated (ATT) for a given structural causal model (SCM), along with its efficiency bound. This statistical quantity is approximated using Monte Carlo sampling.\n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The ATT approximation.\neff_bound: The variance of the counterfactual response, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\natt(scm, treat_all, treat_none)\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.atu-Tuple{StructuralCausalModel}-man-api","page":"API","title":"CausalTables.atu","text":"atu(scm::StructuralCausalModel; samples = 10^6)\n\nApproximate the average treatment effect among the untreated (ATU) for a given structural causal model (SCM), along with its efficiency bound. This statistical quantity is approximated using Monte Carlo sampling.\n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The ATU approximation.\neff_bound: The variance of the counterfactual response, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\natu(scm, treat_all, treat_none)\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.cast_matrix_to_table_function-Tuple{Function}-man-api","page":"API","title":"CausalTables.cast_matrix_to_table_function","text":"cast_matrix_to_table_function(func::Function)\n\nWraps a given function func that operates on a matrix and returns a new function that operates on a CausalTable object. The returned function converts the CausalTable's treatment matrix to a table, applies func to this matrix, and then converts the result back to a column table with the same header as the original treatment matrix.\n\nArguments\n\nfunc::Function: A function that takes a matrix as input and returns a matrix.\n\nReturns\n\nA function that takes a CausalTable object as input and returns a column table.\n\nExample\n\ncustom_intervention = cast_matrix_to_table_function(x -> exp.(x))\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.cfdiff-Tuple{StructuralCausalModel, Function, Function}-man-api","page":"API","title":"CausalTables.cfdiff","text":"cfdiff(scm::StructuralCausalModel, intervention1::Function, intervention2::Function; samples = 10^6)\n\nApproximate the difference between two counterfactual response means – that under intervention1 having been applied to the treatment, and that under intervention2 – for a given structural causal model (SCM), along with its efficiency bound. These statistical quantities are approximated using Monte Carlo sampling. \n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nintervention1::Function: The first intervention function to be contrasted.\nintervention2::Function: The second intervention function to be contrasted.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The mean difference in counterfactual outcomes.\neff_bound: The variance of the difference in counterfactual responses, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\ncfdiff(scm, treat_all, treat_none)\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.cfmean-Tuple{StructuralCausalModel, Function}-man-api","page":"API","title":"CausalTables.cfmean","text":"cfmean(scm::StructuralCausalModel, intervention::Function; samples = 10^6)\n\nApproximate the counterfactual mean of the response had intervention been applied to the treatment, along with its efficiency bound, for a given structural causal model (SCM). These statistical quantities are approximated using Monte Carlo sampling. \n\nArguments\n\nscm::StructuralCausalModel: The SCM from which data is to be simulated.\nintervention::Function: The intervention function to apply to the SCM.\nsamples: The number of samples to draw from scm for Monte Carlo approximation (default is 10^6). This controls the precision of the approximation.\n\nReturns\n\nA named tuple containing:\n\nμ: The mean of the counterfactual outcomes.\neff_bound: The variance of the counterfactual response, which is equal to the efficiency bound for IID data. If observations are correlated, this may not have a meaningful interpretation.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\ncfmean(scm, treat_all)\ncfmean(scm, treat_none)\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.draw_counterfactual-Tuple{StructuralCausalModel, CausalTable, Function}-man-api","page":"API","title":"CausalTables.draw_counterfactual","text":"draw_counterfactual(scm::StructuralCausalModel, parents::CausalTable, intervention::Function) -> Vector\n\nGenerate counterfactual responses based on a given structural causal model (SCM), a table of response parents, and an intervention function. That is, sample the responses that would have occurred had some intervention been applied to the treatment specified by the structural causal model.\n\nArguments\n\nscm::StructuralCausalModel: The structural causal model used to generate counterfactual outcomes.\nparents::CausalTable: A table containing the variables causally preceding the response variable.\nintervention::Function: A function that defines the intervention to be applied to the parent variables.\n\nReturns\n\nA vector of counterfactual responses.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.multiplicative_mtp-Tuple{Any}-man-api","page":"API","title":"CausalTables.multiplicative_mtp","text":"multiplicative_mtp(δ)\n\nConstructs a function that scales the treatment variable(s) in a CausalTable object by a constant δ. This function is intended to be used as an argument to ape.\n\nArguments\n\nδ: The \"multiplicative shift\" to be applied to the treatment variable of a CausalTable.\n\nReturns\n\nA function that takes a CausalTable object as input and returns a column table of treatments that have been scaled by δ units.\n\nExample\n\nusing Distributions\ndgp = CausalTables.@dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Normal(L)),\n    Y ~ @.(Normal(A + 2 * L + 1))\n)\nscm = CausalTables.StructuralCausalModel(dgp, [:A], [:Y], [:L])\nape(scm, multiplicative_mtp(2.0))\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.treat_all-Tuple{CausalTable}-man-api","page":"API","title":"CausalTables.treat_all","text":"treat_all(ct::CausalTable)\n\nIntervenes on a CausalTable object by setting all treatment variables to 1.\n\nArguments\n\nct::CausalTable: A CausalTable object with a univariate binary treatment.\n\nReturns\n\nA NamedTuple object with the same header as the treatment matrix in ct, where each treatment variable is set to 1.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\ndata = rand(scm, 100)\ntreat_all(data)\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.treat_none-Tuple{Any}-man-api","page":"API","title":"CausalTables.treat_none","text":"treat_all(ct::CausalTable)\n\nIntervenes on a CausalTable object by setting all treatment variables to 0.\n\nArguments\n\nct::CausalTable: A CausalTable object with a univariate binary treatment.\n\nReturns\n\nA NamedTuple object with the same header as the treatment matrix in ct, where each treatment variable is set to 0.\n\nExample\n\nusing Distributions\ndgp = @dgp(\n    L ~ Beta(2, 4),\n    A ~ @.(Bernoulli(L)),\n    Y ~ @.(Normal(A + L))\n)\nscm = StructuralCausalModel(dgp, [:A], [:Y], [:L])\ndata = rand(scm, 100)\ntreat_none(data)\n\n\n\n\n\n","category":"method"}]
}
