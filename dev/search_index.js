var documenterSearchIndex = {"docs":
[{"location":"man/getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/network-summaries/#Network-Summaries","page":"Network Summaries","title":"Network Summaries","text":"","category":"section"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"Typically, performing causal inference on a network relies on summarizing the treatment and covariates of each unit's neighbors using some sort of summary function. For example, in a study evaluating the effect of electric vehicle adoption on air pollution, one might model the commuting patterns between counties as a network and evaluate the effect of the sum the number of electric vehicles commuting into each county. The following documents summary measures available in CausalTables.jl and how to summarize a CausalTable","category":"page"},{"location":"man/network-summaries/#Summarizing-a-CausalTable","page":"Network Summaries","title":"Summarizing a CausalTable","text":"","category":"section"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"Data wrapped in a CausalTable includes a NamedTuple summaries which describes extra variables represented as summary variables over the network. These summary measures can be computed and added to the table by calling the summarize function on the CausalTable object.","category":"page"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"summarize","category":"page"},{"location":"man/network-summaries/#CausalTables.summarize","page":"Network Summaries","title":"CausalTables.summarize","text":"summarize(x::CausalTable, keep = true)\n\nSummarize a CausalTable by computing the summaries specified in the summaries field of the CausalTable and adding them to the existing data.\n\nArguments\n\nx::CausalTable: The CausalTable to be summarized.\nkeep_original::Bool: Whether to return a CausalTable with summarized variables appended (true) or a Tables-compatible NamedTuple with only the summarized variables (false).\n\nReturns\n\nIf keep_original is true, a new CausalTable with merged columns, treatment, response, graph, and summaries. Otherwise, NamedTuple of just variable summaries\n\nExample\n\nusing Graphs\n\n# Construct a CausalTable\nctbl = CausalTable(\n    (A = [1, 2, 3],);\n    graph = Graphs.complete_graph(3),\n    summaries = (As = Sum(:A), Am = Maximum(:A))\n)\n\n# Compute the summaries of the CausalTable\nsummarize(ctbl)\n\n# output\nCausalTable((A = [1, 2, 3], As = [5, 4, 3], Am = [3, 3, 2]), nothing, nothing, nothing, SimpleGraph{Int64}(3, [[2, 3], [1, 3], [1, 2]]), (As = Sum(:A, true), Am \n= Maximum(:A, true)))\n\n\n\n\n\n","category":"function"},{"location":"man/network-summaries/#Existing-Summary-Measures","page":"Network Summaries","title":"Existing Summary Measures","text":"","category":"section"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"The following lists summary measures currently available off-the-shelf in CausalTables.jl. Examples on their use are provided in Generating Data for Statistical Experiments and Turning data into a CausalTable.","category":"page"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"Sum","category":"page"},{"location":"man/network-summaries/#CausalTables.Sum","page":"Network Summaries","title":"CausalTables.Sum","text":"Sum(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the sum of var_to_summarize over each unit's neighbors. If var_to_summarize is X, then mathematically this computes\n\nsum_j in mathcalF_i X_j\n\nwhere F_i represents the \"friends\" or neighbors of unit i.\n\nArguments\n\nvar_to_summarize::Symbol: The variable to summarize.\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\ninclude_self::Bool: Whether to include the value of var_to_summarize for the unit itself in the sum. Default is true.\n\nReturns\n\nSum: The constructed Sum object.\n\n\n\n\n\n","category":"type"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"Product","category":"page"},{"location":"man/network-summaries/#CausalTables.Product","page":"Network Summaries","title":"CausalTables.Product","text":"Product(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the product of var_to_summarize over each unit's neighbors. If var_to_summarize is X, then mathematically this computes\n\nprod_j in mathcalF_i X_j\n\nwhere F_i represents the \"friends\" or neighbors of unit i.\n\nArguments\n\nvar_to_summarize::Symbol: The variable to summarize.\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\n\nReturns\n\nProduct: The constructed Product object.\n\n\n\n\n\n","category":"type"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"Maximum","category":"page"},{"location":"man/network-summaries/#CausalTables.Maximum","page":"Network Summaries","title":"CausalTables.Maximum","text":"Maximum(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the maximum of var_to_summarize over each unit's neighbors. If var_to_summarize is X, then mathematically this computes\n\nmax_j in mathcalF_i X_j\n\nwhere F_i represents the \"friends\" or neighbors of unit i.\n\nArguments\n\nvar_to_summarize::Symbol: The variable to summarize.\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\n\nReturns\n\nMaximum: The constructed Maximum object.\n\n\n\n\n\n","category":"type"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"Minimum","category":"page"},{"location":"man/network-summaries/#CausalTables.Minimum","page":"Network Summaries","title":"CausalTables.Minimum","text":"Minimum(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the minimum of var_to_summarize over each unit's neighbors. If var_to_summarize is X, then mathematically this computes\n\nmin_j in mathcalF_i X_j\n\nwhere F_i represents the \"friends\" or neighbors of unit i.\n\nArguments\n\nvar_to_summarize::Symbol: The variable to summarize.\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\n\nReturns\n\nMinimum: The constructed Minimum object.\n\n\n\n\n\n","category":"type"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"Mode","category":"page"},{"location":"man/network-summaries/#CausalTables.Mode","page":"Network Summaries","title":"CausalTables.Mode","text":"Mode(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the mode of var_to_summarize over each unit's neighbors â€“ that is, the value occuring most often among units connected to each unit in the network.\n\nArguments\n\nvar_to_summarize::Symbol: The variable to summarize.\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\n\nReturns\n\nMode: The constructed Mode object.\n\n\n\n\n\n","category":"type"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"Friends","category":"page"},{"location":"man/network-summaries/#CausalTables.Friends","page":"Network Summaries","title":"CausalTables.Friends","text":"Friends(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the number of neighbors of each unit in the network.\n\nArguments\n\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\n\nReturns\n\nFriends: The constructed Friends object.\n\n\n\n\n\n","category":"type"},{"location":"man/network-summaries/#Defining-Your-Own-Summary-Measures","page":"Network Summaries","title":"Defining Your Own Summary Measures","text":"","category":"section"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"If you want to use a custom summary measure, you can define your own by creating a new type that is a subtype of NetworkSummary. The following example shows how to define a new summary measure that computes the mode of a variable over a unit's neighbors:","category":"page"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"mutable struct Mode <: NetworkSummary \n    var_to_summarize::Symbol\n    use_inneighbors::Bool\n    include_self::Bool\n    Mode(var_to_summarize::Symbol; use_inneighbors::Bool = true, include_self = true) = new(var_to_summarize, use_inneighbors, include_self)\nend","category":"page"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"Then, simply add a new function to the summarize method by defining summarize(x::CausalTable, summary::NetworkSummary) function, but replacing the NetworkSummary with your new summary type. One easy way to define a new summarize function is to use apply_function_over_neighbors. This takes a function taking a vector as input and applies it to the variable specified in second argument, filtered to each unit's neighbors. ","category":"page"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"In this case, we can use StatsBase.mode to compute the mode of each unit's neighbors. ","category":"page"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"apply_function_over_neighbors","category":"page"},{"location":"man/network-summaries/#CausalTables.apply_function_over_neighbors","page":"Network Summaries","title":"CausalTables.apply_function_over_neighbors","text":"apply_function_over_neighbors(x::CausalTable, var_to_summarize::Symbol, summary_func::Function; use_inneighbors = true)\n\nApply a summary function over the neighbors of each row in a CausalTable. Mostly used as a utility to define a summarize function for new NetworkSummary types.\n\nArguments\n\nx::CausalTable: The CausalTable object.\nvar_to_summarize::Symbol: The symbol representing the variable in the CausalTable to summarize.\nsummary_func::Function: The summary function to apply. Should take in a vector as input.\nuse_inneighbors::Bool: (optional) If true, use the in-neighbors of each row as neighbors. If false, use the out-neighbors. Default is true.\n\nReturns\n\nA Vector containing the summary value for each row.\n\n\n\n\n\n","category":"function"},{"location":"man/network-summaries/","page":"Network Summaries","title":"Network Summaries","text":"summarize(x::CausalTable, summary::Mode) = apply_function_over_neighbors(x, summary.var_to_summarize, StatsBase.mode; use_inneighbors = summary.use_inneighbors)","category":"page"},{"location":"man/ground-truth/#Computing-Ground-Truth-Conditional-Distributions","page":"Computing Ground Truth of Causal Parameters","title":"Computing Ground Truth Conditional Distributions","text":"","category":"section"},{"location":"man/ground-truth/","page":"Computing Ground Truth of Causal Parameters","title":"Computing Ground Truth of Causal Parameters","text":"Once we've defined a DGP and have some table of data with variables matching those of our DGP, we can compute the ground truth conditional distributions of any variable in a CausalTable (given a corresponding DGP) using the condensity function. This returns a Distribution object from the package Distributions.jl.","category":"page"},{"location":"man/ground-truth/","page":"Computing Ground Truth of Causal Parameters","title":"Computing Ground Truth of Causal Parameters","text":"Let's see an example. First, we'll define a DGP:","category":"page"},{"location":"man/ground-truth/","page":"Computing Ground Truth of Causal Parameters","title":"Computing Ground Truth of Causal Parameters","text":"using Graphs\nusing CausalTables\nusing Random\n\ndistributions = @dgp(\n        W ~ Binomial(10, 0.3),\n        X ~ (@. Normal(:W + 1)),\n        Xs = Sum(:X),\n        Y ~ (@. LogNormal(log(0.2 * :Xs + 4), 0.1 * :W + 1))\n    )\n\ndgp = DataGeneratingProcess(\n    n -> erdos_renyi(n, 0.5),\n    distributions;\n    treatment = :Xs,\n    response = :Y,\n    controls = [:W]\n)","category":"page"},{"location":"man/ground-truth/","page":"Computing Ground Truth of Causal Parameters","title":"Computing Ground Truth of Causal Parameters","text":"Now, let's generate some data and compute the ground truth conditional distributions of the variables in the data. Note that if the DGP attempts to summarize a variable with no neighbors in a graph, the resulting conditional distribution will currently be Binomial(0, 0.5), which denotes a point-mass distribution at 0.","category":"page"},{"location":"man/ground-truth/","page":"Computing Ground Truth of Causal Parameters","title":"Computing Ground Truth of Causal Parameters","text":"Random.seed!(1);\ndata = rand(dgp, 5)\nW_distribution = condensity(dgp, data, :W)\nX_distribution = condensity(dgp, data, :X)\nXs_distribution = condensity(dgp, data, :Xs)","category":"page"},{"location":"man/ground-truth/","page":"Computing Ground Truth of Causal Parameters","title":"Computing Ground Truth of Causal Parameters","text":"One can also compute the ground truth conditional mean of a variable in a CausalTable using the conmean function:","category":"page"},{"location":"man/ground-truth/","page":"Computing Ground Truth of Causal Parameters","title":"Computing Ground Truth of Causal Parameters","text":"Y = conmean(dgp, data, :Y)","category":"page"},{"location":"man/generating-data/#Generating-Data-for-Statistical-Experiments","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"","category":"section"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"When evaluating a causal inference method, we often want to test it on data from a known causal model. CausalTables.jl allows us to define a DataGeneratingProcess (or DGP) to do just that. ","category":"page"},{"location":"man/generating-data/#Defining-a-DataGeneratingProcess","page":"Generating Data for Statistical Experiments","title":"Defining a DataGeneratingProcess","text":"","category":"section"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"To start, we need to define a Vector of Pairs of the form variable name => (; O...) -> Distribution(args...). The Distribution should take arguments corresponding to the names of the variables in the DGP. For example, suppose we wanted to define a statistical model of the form","category":"page"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"beginalign*\n    W sim textDiscreteUniform(1 5) \n    X sim textNormal(W 1) \n    Y sim textNormal(X + 02W 1)\nendalign*","category":"page"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"where X is the treatment, Y is the response, and W is a control variable. A verbose and inconvenient (albeit correct) way to define this DGP would be as follows:","category":"page"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"using Distributions\n\ndistributions = [\n        :W => (; O...) -> DiscreteUniform(1, 5),\n        :X => (; O...) -> (@. Normal(O[:W], 1)),\n        :Y => (; O...) -> (@. Normal(O[:X] + 0.2 * O[:W], 1))\n    ]","category":"page"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"Note how Distributions can take previous variables as arguments by referencing them from the object O. The ; O... syntax is a shorthand for a function that takes keyword arguments corresponding to the names of the variables in the DGP. ","category":"page"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"However, a much more convenient way to define this DGP is using the @dgp macro, which takes a sequence of conditional distributions of the form [variable name] ~ Distribution(args...) and automatically generates a valid Vector of Pairs for a DataGeneratingProcess. For example, the easier way to define the DGP above is as follows:","category":"page"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"using CausalTables\ndistributions = @dgp(\n        W ~ DiscreteUniform(1, 5),\n        X ~ (@. Normal(:W, 1)),\n        Y ~ (@. Normal(:X + 0.2 * :W, 1))\n    )","category":"page"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"Note that with the @dgp macro, any symbol used in Distribution is automatically replaced with the corresponding previously-defined variable in the process. For instance, in Normal(:W, 1), the :W will be replaced automatically with the distribution we defined as W earlier in the sequence. With this vector in hand, we can define a DataGeneratingProcess object like so â€“ treatment, response, and control variables in the causal model are specified as keyword arguments to the DataGeneratingProcess constructor:","category":"page"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"dgp = DataGeneratingProcess(\n    distributions;\n    treatment = :X,\n    response = :Y,\n    controls = [:W]\n)","category":"page"},{"location":"man/generating-data/#Networks-of-Causally-Connected-Units","page":"Generating Data for Statistical Experiments","title":"Networks of Causally-Connected Units","text":"","category":"section"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"In some cases, we might work with data in which units may not be causally independent, but rather, in which one unit's variables could dependent on some summary function of its neighbors. Generating data from such a model can be done with two modifications:","category":"page"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"Summary functions of neighbors are included in the @dgp macro via the form varname = NetworkSummary(args...); see more information on avaible summaries in Network Summaries\nThe DataGeneratingProcess constructor is called with a function that takes in a sample size n and reutrns a Graph object from Graphs.jl, which is used to determine which units are neighbors of one another.","category":"page"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"Here's an example of how such a DataGeneratingProcess might be constructed:","category":"page"},{"location":"man/generating-data/","page":"Generating Data for Statistical Experiments","title":"Generating Data for Statistical Experiments","text":"using Graphs\nusing CausalTables\n\ndistributions = @dgp(\n        W ~ DiscreteUniform(1, 5),\n        Ws = Sum(:W),\n        X ~ (@. Normal(:Ws, 1)),\n        Xs = Sum(:X),\n        Y ~ (@. Normal(:Xs + 0.2 * :Ws, 1))\n    )\n\ndgp = DataGeneratingProcess(\n    n -> erdos_renyi(n, 0.3),\n    distributions;\n    treatment = :Xs,\n    response = :Y,\n    controls = [:W, :Ws]\n)","category":"page"},{"location":"man/formatting/#Turning-Your-Data-Into-a-CausalTable","page":"Turning data into a CausalTable","title":"Turning Your Data Into a CausalTable","text":"","category":"section"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"One of the main purposes of CausalTables.jl is to wrap a Table of data in Julia in order to provide it as input to some other causal inference package. Given a Table of some data, we can turn it into a CausalTable by specifying the treatment, response, and control variables. ","category":"page"},{"location":"man/formatting/#Tables-with-Causally-Independent-Units","page":"Turning data into a CausalTable","title":"Tables with Causally Independent Units","text":"","category":"section"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"The code below demonstrates this on the Titanic dataset. This could be, for example, to use as input into some estimator of whether a passenger's sex caused them to survive the Titanic disaster, controlling for some baselineline covariates listed in controls.","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"using CausalTables\nusing MLDatasets: Titanic\nusing DataFrames\n\ndf = Titanic().dataframe\n\n# Wrapping the dataset in a CausalTable\nctbl = CausalTable(df; treatment = :Sex, response = :Survived, controls = [:Pclass, :Age, :SibSp])\n\nnothing # hide","category":"page"},{"location":"man/formatting/#Tables-with-Network-Dependent-Units","page":"Turning data into a CausalTable","title":"Tables with Network-Dependent Units","text":"","category":"section"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"The previous example assumes that each unit (row in the Table, in this case df), is \"causally independent\" of every other unit â€“ that is, the treatment of one unit does not affect the response of any other unit. In some cases, however, we might work with data in which units may not be causally independent, but rather, in which one unit's variables could dependent on some summary function of its neighbors. ","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"In this case, we can specify a graph argument to the CausalTable constructor, a Graph object from Graphs.jl which will be used to determine which units are neighbors of one another. We would also specify a summaries argument, a NamedTuple of NetworkSummary objects representing variables summarized over each unit's neighbors in the graph. More detail on the types of NetworkSummary that can be used in a dependent-data CausalTable can be found in Network Summaries","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"Here's an example of how such a CausalTable might be constructed, using the Karate Club dataset. Treatment is defined as the number of friends a club member has, denoted by the summary function parameter summaries = (friends = Friends(),). ","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"using CausalTables\nusing MLDatasets\nusing Graphs\n\n# Get a Table of Karate Club data from MLDatasets\ndata = KarateClub()\ntbl = data.graphs[1].node_data\n\n# Convert the karate club data into a Graphs.jl graph object\ng = SimpleGraphFromIterator([Edge(x...) for x in zip(data.graphs[1].edge_index...)])\n\n# Note that the input to summaries must be a NamedTuple, even if there is only one summary variable, so the trailing comma is necessary.\nctbl = CausalTable(tbl; graph = g, treatment = :friends, response = :labels_clubs, summaries = (friends = Friends(),))\n\nnothing # hide","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"Be warned: if you try to call gettreatment on a CausalTable that has not been summarized, you will get an error:","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"try  #hide\ngettreatment(ctbl)\ncatch err; showerror(stderr, err); end  #hide","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"If you wish to extract the treatment variable, you will first need to call summarize on the CausalTable object, which computes the summary variables over the network. Then, calling gettreatment will yield the summarized treatment variable, like so:","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"ctbl_summarized = summarize(ctbl)\ngettreatment(ctbl_summarized)","category":"page"},{"location":"man/formatting/","page":"Turning data into a CausalTable","title":"Turning data into a CausalTable","text":"The response and controls can also be extracted using getresponse and getcontrols, respectively. ","category":"page"},{"location":"#CausalTables.jl","page":"Home","title":"CausalTables.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A package for storing and simulating data for causal inference in Julia.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CausalTables.jl can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg> add CausalTables","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CausalTables.jl has three main functionalities:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generating simulation data using a DataGeneratingProcess\nComputing \"ground truth\" conditional distributions, means, and other functionals from a DataGeneratingProcess and a CausalTable\nWrapping an existing Table to make it a CausalTable for use by external packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The examples below illustrate each of these three functionalities.","category":"page"},{"location":"#Simulating-Data-from-a-DataGeneratingProcess","page":"Home","title":"Simulating Data from a DataGeneratingProcess","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To set up a statistical simulation using CausalTables.jl, we first define a DataGeneratingProcess (DGP). The easiest way to do this is using the @dgp macro, which takes a sequence of conditional distributions of the form [variable name] ~ Distribution(args...) and returns a DataGeneratingProcess object like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CausalTables\nusing Random\n\ndistributions = @dgp(\n        W ~ DiscreteUniform(1, 5),\n        X ~ (@. Normal(:W, 1)),\n        Y ~ (@. Normal(:X + 0.2 * :W, 1))\n    )\n\ndgp = DataGeneratingProcess(\n    distributions;\n    treatment = :X,\n    response = :Y,\n    controls = [:W]\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"One we've defined our list of distribution functions, we can generate data from the DGP using the rand function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Random.seed!(1);\ndata = rand(dgp, 5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more detailed guide of how to generate data please refer to Generating Data.","category":"page"},{"location":"#Computing-Ground-Truth-Conditional-Distributions","page":"Home","title":"Computing Ground Truth Conditional Distributions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once we've defined a DGP and have some table of data with variables matching those of our DGP, we can compute the ground truth conditional distributions of any variable in a CausalTable (given a corresponding DGP) using the condensity function. This returns a Distribution object from the package Distributions.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"X_distribution = condensity(dgp, data, :X)\n\n# output\n5-element Vector{Distributions.Normal{Float64}}:\n Distributions.Normal{Float64}(Î¼=1.0, Ïƒ=1.0)\n Distributions.Normal{Float64}(Î¼=2.0, Ïƒ=1.0)\n Distributions.Normal{Float64}(Î¼=4.0, Ïƒ=1.0)\n Distributions.Normal{Float64}(Î¼=4.0, Ïƒ=1.0)\n Distributions.Normal{Float64}(Î¼=5.0, Ïƒ=1.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For convenience, there also exists a conmean function that extracts the true conditional mean of a specific variable the CausalTable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Y_mean = conmean(dgp, data, :Y)\n\n# output\n5-element Vector{Float64}:\n 1.467564418628885\n 4.149933692528245\n 3.973979208080703\n 3.757247582108903\n 5.670866154143596","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more detailed guide of how to compute ground truth conditional distributions please refer to Computing Ground Truth Conditional Distributions.","category":"page"},{"location":"#Wrapping-an-existing-Table-as-a-CausalTable","page":"Home","title":"Wrapping an existing Table as a CausalTable","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have a table of data that you would like to use with CausalTables.jl without defining a corresponding DataGeneratingProcess (i.e. to use with another package) you can wrap it as a CausalTable using the corresponding constructor:","category":"page"},{"location":"","page":"Home","title":"Home","text":"tbl = (W = rand(1:5, 10), X = randn(10), Y = randn(10))\nctbl = CausalTable(tbl; treatment = :X, response = :Y, controls = [:W])","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a more detailed guide of how to wrap an existing table as a CausalTable please refer to Turning Your Data Into a CausalTable.","category":"page"},{"location":"man/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"man/api/","page":"API","title":"API","text":"The following documents public methods of CausalTables.jl.","category":"page"},{"location":"man/api/","page":"API","title":"API","text":"Modules = [CausalTables]\nOrder   = [:function, :type]","category":"page"},{"location":"man/api/#Base.rand-Tuple{DataGeneratingProcess, Int64}","page":"API","title":"Base.rand","text":"rand(dgp::DataGeneratingProcess, n::Int)\n\nGenerate a random CausalTable using the specified DataGeneratingProcess.\n\nArguments\n\ndgp::DataGeneratingProcess: The DataGeneratingProcess object defining the causal network and distribution steps.\nn::Int: The number of observations to generate.\n\nReturns\n\nct::CausalTable: The generated CausalTable.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.apply_function_over_neighbors-Tuple{CausalTable, Symbol, Function}","page":"API","title":"CausalTables.apply_function_over_neighbors","text":"apply_function_over_neighbors(x::CausalTable, var_to_summarize::Symbol, summary_func::Function; use_inneighbors = true)\n\nApply a summary function over the neighbors of each row in a CausalTable. Mostly used as a utility to define a summarize function for new NetworkSummary types.\n\nArguments\n\nx::CausalTable: The CausalTable object.\nvar_to_summarize::Symbol: The symbol representing the variable in the CausalTable to summarize.\nsummary_func::Function: The summary function to apply. Should take in a vector as input.\nuse_inneighbors::Bool: (optional) If true, use the in-neighbors of each row as neighbors. If false, use the out-neighbors. Default is true.\n\nReturns\n\nA Vector containing the summary value for each row.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.condensity-Tuple{DataGeneratingProcess, CausalTable, Symbol}","page":"API","title":"CausalTables.condensity","text":"condensity(dgp::DataGeneratingProcess, ct::CausalTable, var::Symbol)\n\nCompute the conditional density of a variable in a CausalTable based on a DataGeneratingProcess.\n\nArguments\n\ndgp::DataGeneratingProcess: The DataGeneratingProcess object representing the data generating process.\nct::CausalTable: The CausalTable object containing the data.\nvar::Symbol: The name of the variable for which to compute the conditional density.\n\nReturns\n\nThe conditional density of the variable in the CausalTable.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.conmean-Tuple{DataGeneratingProcess, CausalTable, Symbol}","page":"API","title":"CausalTables.conmean","text":"conmean(dgp::DataGeneratingProcess, ct::CausalTable, var::Symbol)\n\nCompute the conditional mean of a variable in a CausalTable based on a DataGeneratingProcess.\n\nArguments\n\ndgp::DataGeneratingProcess: The DataGeneratingProcess object representing the data generating process.\nct::CausalTable: The CausalTable object representing the data.\nvar::Symbol: The variable for which to compute the conditional mean.\n\nReturns\n\nAn array of conditional means for the specified variable.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.getcontrols-Tuple{CausalTable}","page":"API","title":"CausalTables.getcontrols","text":"getcontrols(x::CausalTable)\n\nSelects the control variables from the given CausalTable object x.\n\nArguments\n\nx::CausalTable: The CausalTable object from which to select the control variables.\nkeepcausal::Bool: Determines whether to keep the CausalTable wrapping or return a NamedTuple. Default is true.\n\nReturns\n\nA new CausalTable object containing only the control variables.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.getgraph-Tuple{CausalTable}","page":"API","title":"CausalTables.getgraph","text":"getgraph(x::CausalTable)\n\nGet the graph associated with a CausalTable.\n\nArguments\n\nx::CausalTable: The CausalTable object.\n\nReturns\n\nThe graph associated with the CausalTable.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.getresponse-Tuple{CausalTable}","page":"API","title":"CausalTables.getresponse","text":"getresponse(x::CausalTable)\n\nGet the response variable from a CausalTable.\n\nArguments\n\nx::CausalTable: The CausalTable object.\n\nReturns\n\nThe response variable from the CausalTable.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.getsummaries-Tuple{CausalTable}","page":"API","title":"CausalTables.getsummaries","text":"getsummaries(x::CausalTable)\n\nArguments\n\nx::CausalTable: The CausalTable object.\n\nReturns\n\nAn array of tables stored in the CausalTable x.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.gettable-Tuple{CausalTable}","page":"API","title":"CausalTables.gettable","text":"gettable(x::CausalTable)\n\nExtracts the underlying table from a CausalTable.\n\nArguments\n\nx::CausalTable: The CausalTable object.\n\nReturns\n\nThe underlying table.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.gettreatment-Tuple{CausalTable}","page":"API","title":"CausalTables.gettreatment","text":"gettreatment(x::CausalTable)\n\nGet the treatment column from a CausalTable.\n\nArguments\n\nx::CausalTable: The CausalTable object.\n\nReturns\n\nThe treatment column of the CausalTable.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.replace-Tuple{CausalTable}","page":"API","title":"CausalTables.replace","text":"replace(x::CausalTable; tbl = nothing, treatment = nothing, response = nothing, controls = nothing, graph = nothing, summaries = nothing)\n\nConviently replace several components of a CausalTable with new values.\n\nArguments:\n\nx::CausalTable: The CausalTable object to modify.\ntbl: The new table to replace the existing table. If nothing, the current table is used.\ntreatment: The new treatment symbol to replace the existing treatment symbol. If nothing, the current treatment symbol is used.\nresponse: The new response symbol to replace the existing response symbol. If nothing, the current response symbol is used.\ncontrols: The new control symbols to replace the existing control symbols. If nothing, the current control symbols are used.\ngraph: The new graph to replace the existing graph. If nothing, the current graph is used.\nsummaries: The new summaries to replace the existing summaries. If nothing, the current summaries are used.\n\nReturns:\n\nCausalTable: The modified CausalTable object.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.replacetable-Tuple{CausalTable, Any}","page":"API","title":"CausalTables.replacetable","text":"replacetable(x::CausalTable, tbl)\n\nConveniently replace the underlying table of a CausalTable with a new table.\n\nArguments\n\nx::CausalTable: The CausalTable object to replace the table for.\ntbl: The new table to replace the existing table with.\n\nReturns\n\nA new CausalTable object with the updated table.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.setcausalvars!-Tuple{CausalTable}","page":"API","title":"CausalTables.setcausalvars!","text":"setcausalvars!(x::CausalTable; treatment=nothing, response=nothing, controls=nothing)\n\nConvenience function for setting new treatment, response, and controls variables for a CausalTable at once.\n\nArguments:\n\nx::CausalTable: The CausalTable object.\ntreatment=nothing: The treatment variable.\nresponse=nothing: The response variable.\ncontrols=nothing: The control variables.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.setcontrols!-Tuple{CausalTable, Vector{Symbol}}","page":"API","title":"CausalTables.setcontrols!","text":"setcontrols!(x::CausalTable, controls::Vector{Symbol})\n\nSet the control variables for a CausalTable.\n\nArguments\n\nx::CausalTable: The CausalTable object.\ncontrols::Vector{Symbol}: The new control variables to be set.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.setresponse!-Tuple{CausalTable, Symbol}","page":"API","title":"CausalTables.setresponse!","text":"setresponse!(x::CausalTable, response::Symbol)\n\nSet the response variable for a CausalTable.\n\nArguments\n\nx::CausalTable: The CausalTable object.\nresponse::Symbol: The symbol representing the new response variable.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.settreatment!-Tuple{CausalTable, Symbol}","page":"API","title":"CausalTables.settreatment!","text":"settreatment!(x::CausalTable, treatment::Symbol)\n\nSet the treatment variable for a CausalTable.\n\nArguments\n\nx::CausalTable: The CausalTable object.\ntreatment::Symbol: The symbol representing the new treatment variable.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.summarize-Tuple{CausalTable}","page":"API","title":"CausalTables.summarize","text":"summarize(x::CausalTable, keep = true)\n\nSummarize a CausalTable by computing the summaries specified in the summaries field of the CausalTable and adding them to the existing data.\n\nArguments\n\nx::CausalTable: The CausalTable to be summarized.\nkeep_original::Bool: Whether to return a CausalTable with summarized variables appended (true) or a Tables-compatible NamedTuple with only the summarized variables (false).\n\nReturns\n\nIf keep_original is true, a new CausalTable with merged columns, treatment, response, graph, and summaries. Otherwise, NamedTuple of just variable summaries\n\nExample\n\nusing Graphs\n\n# Construct a CausalTable\nctbl = CausalTable(\n    (A = [1, 2, 3],);\n    graph = Graphs.complete_graph(3),\n    summaries = (As = Sum(:A), Am = Maximum(:A))\n)\n\n# Compute the summaries of the CausalTable\nsummarize(ctbl)\n\n# output\nCausalTable((A = [1, 2, 3], As = [5, 4, 3], Am = [3, 3, 2]), nothing, nothing, nothing, SimpleGraph{Int64}(3, [[2, 3], [1, 3], [1, 2]]), (As = Sum(:A, true), Am \n= Maximum(:A, true)))\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Distributions.convolve-Union{Tuple{Vector{T}}, Tuple{T}} where T<:(Distributions.UnivariateDistribution)","page":"API","title":"Distributions.convolve","text":"Distributions.convolve(ds::Vector{T}) where {T <: UnivariateDistribution}\n\nOverload the convolve function to work on a vector of UnivariateDistribution.\n\nArguments\n\nds::Vector{T}: A vector of UnivariateDistribution objects.\n\nReturns\n\noutput: The result of convolving all the distributions in ds.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#Tables.subset-Tuple{CausalTable, Any}","page":"API","title":"Tables.subset","text":"subset(x::CausalTable, ind)\n\nSubset a CausalTable x based on the given indices ind. Note that viewhinting is not supported; this function will return a copy of the CausalTable.\n\nArguments\n\nx: The CausalTable to be subsetted.\nind: The indices to subset the table and graph.\n\nReturns\n\nA new CausalTable with the subsetted table. If the graph attribute is not Nothing, then this function takes the subgraph induced by the subsetted indices using induced\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.CausalTable","page":"API","title":"CausalTables.CausalTable","text":"CausalTable\n\nA mutable structure that contains a table (tbl), a graph (graph), and a named tuple of summaries (summaries).\n\n\n\n\n\n","category":"type"},{"location":"man/api/#CausalTables.DataGeneratingProcess","page":"API","title":"CausalTables.DataGeneratingProcess","text":"struct DataGeneratingProcess\n\nA mutable struct representing a data generating process.\n\nFields\n\nnetworkgen::Function: A function that generates the network structure.\ndistgen::Vector{Pair{Symbol, ValidDGPTypes}}: A vector of pairs representing the distribution generators for each variable.\ntreatment::Symbol: The symbol representing the treatment variable.\nresponse::Symbol: The symbol representing the response variable.\ncontrols::Vector{Symbol}: A vector of symbols representing the control variables.\n\n\n\n\n\n","category":"type"},{"location":"man/api/#CausalTables.Friends-Tuple{}","page":"API","title":"CausalTables.Friends","text":"Friends(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the number of neighbors of each unit in the network.\n\nArguments\n\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\n\nReturns\n\nFriends: The constructed Friends object.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.Maximum-Tuple{Symbol}","page":"API","title":"CausalTables.Maximum","text":"Maximum(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the maximum of var_to_summarize over each unit's neighbors. If var_to_summarize is X, then mathematically this computes\n\nmax_j in mathcalF_i X_j\n\nwhere F_i represents the \"friends\" or neighbors of unit i.\n\nArguments\n\nvar_to_summarize::Symbol: The variable to summarize.\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\n\nReturns\n\nMaximum: The constructed Maximum object.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.Minimum-Tuple{Symbol}","page":"API","title":"CausalTables.Minimum","text":"Minimum(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the minimum of var_to_summarize over each unit's neighbors. If var_to_summarize is X, then mathematically this computes\n\nmin_j in mathcalF_i X_j\n\nwhere F_i represents the \"friends\" or neighbors of unit i.\n\nArguments\n\nvar_to_summarize::Symbol: The variable to summarize.\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\n\nReturns\n\nMinimum: The constructed Minimum object.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.Mode-Tuple{Symbol}","page":"API","title":"CausalTables.Mode","text":"Mode(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the mode of var_to_summarize over each unit's neighbors â€“ that is, the value occuring most often among units connected to each unit in the network.\n\nArguments\n\nvar_to_summarize::Symbol: The variable to summarize.\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\n\nReturns\n\nMode: The constructed Mode object.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.NetworkSummary","page":"API","title":"CausalTables.NetworkSummary","text":"abstract type NetworkSummary\n\nAbstract type representing a summary of a network.\n\n\n\n\n\n","category":"type"},{"location":"man/api/#CausalTables.Product-Tuple{Symbol}","page":"API","title":"CausalTables.Product","text":"Product(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the product of var_to_summarize over each unit's neighbors. If var_to_summarize is X, then mathematically this computes\n\nprod_j in mathcalF_i X_j\n\nwhere F_i represents the \"friends\" or neighbors of unit i.\n\nArguments\n\nvar_to_summarize::Symbol: The variable to summarize.\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\n\nReturns\n\nProduct: The constructed Product object.\n\n\n\n\n\n","category":"method"},{"location":"man/api/#CausalTables.Sum-Tuple{Symbol}","page":"API","title":"CausalTables.Sum","text":"Sum(var_to_summarize::Symbol; use_inneighbors::Bool = true)\n\nConstructs a Network Summary denoting the sum of var_to_summarize over each unit's neighbors. If var_to_summarize is X, then mathematically this computes\n\nsum_j in mathcalF_i X_j\n\nwhere F_i represents the \"friends\" or neighbors of unit i.\n\nArguments\n\nvar_to_summarize::Symbol: The variable to summarize.\nuse_inneighbors::Bool: Whether to use the in-neighbors or out-neighbors. If true, then the in-neighbors are used. If the graph is undirected, this has no effect.\ninclude_self::Bool: Whether to include the value of var_to_summarize for the unit itself in the sum. Default is true.\n\nReturns\n\nSum: The constructed Sum object.\n\n\n\n\n\n","category":"method"}]
}
